# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è ZIP —Ñ–∞–π–ª–æ–≤
@router.callback_query(lambda c: c.data.startswith("download:"))
async def download_material(callback_query: CallbackQuery, state: FSMContext):

    user_id = callback_query.from_user.id
    can_use, response_message = await can_use_feature(user_id)
    await callback_query.message.edit_reply_markup(reply_markup=None)
    await callback_query.message.answer('–û—Ç–ø—Ä–∞–≤–ª—è—é –í–∞–º –º–∞—Ç–µ—Ä–∏–∞–ª—ã...')

    if can_use != 2:
        await callback_query.message.answer(response_message, reply_markup=material_menu)
        await state.clear()

    data = await state.get_data()
    bot = callback_query.bot
    user_id = str(callback_query.from_user.id) 
    material_id = int(callback_query.data.split(':')[-1])
    
    # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ –∏–∑ –ë–î
    files_data_text = await get_file_id_material(material_id)  # –ó–¥–µ—Å—å –≤–∞—à –º–µ—Ç–æ–¥ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∏–∑ –ë–î
    files_data = json.loads(files_data_text.replace("'", '"'))
    file_ids = [item['file_id'] for item in files_data]  # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–æ–ª—å–∫–æ file_id
    
    # –°–æ–∑–¥–∞—ë–º –≤—Ä–µ–º–µ–Ω–Ω—É—é –ø–∞–ø–∫—É –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤
    user_folder = f"temp_files/{user_id}"
    os.makedirs(user_folder, exist_ok=True)
    zip_filename = f"{user_folder}/{data['topic']}.zip"

    # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–∞–π–ª—ã –∏ —Å–æ–∑–¥–∞—ë–º ZIP-–∞—Ä—Ö–∏–≤
    with zipfile.ZipFile(zip_filename, 'w') as zipf:
        for idx, file_id in enumerate(file_ids):
            file = await bot.get_file(file_id)  # –ü–æ–ª—É—á–∞–µ–º —Ñ–∞–π–ª —Å —Å–µ—Ä–≤–µ—Ä–∞ Telegram
            local_file_path = os.path.join(user_folder, f"file_{idx}.{file.file_path.split('.')[-1]}")
            await bot.download_file(file.file_path, local_file_path)  # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–∞–π–ª
            
            zipf.write(local_file_path, f"file_{idx}.{file.file_path.split('.')[-1]}")  # –î–æ–±–∞–≤–ª—è–µ–º –≤ –∞—Ä—Ö–∏–≤
            os.remove(local_file_path)  # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –∞—Ä—Ö–∏–≤

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∞—Ä—Ö–∏–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    document = FSInputFile(zip_filename)
    caption_text = (
        f"–í–∞—à–∏ –º–∞—Ç–µ—Ä–∏–∞–ª—ã —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã üìÇ\n\n"
        f"–§–∞–π–ª—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ –∞—Ä—Ö–∏–≤–µ –ø–æ–¥ ID: {material_id}. –ë–ª–∞–≥–æ–¥–∞—Ä–∏–º –∑–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –Ω–∞—à–µ–≥–æ —Å–µ—Ä–≤–∏—Å–∞!\n"
        "–ù–µ –∑–∞–±—É–¥—å—Ç–µ –æ—Ü–µ–Ω–∏—Ç—å –º–∞—Ç–µ—Ä–∏–∞–ª ‚Äî —ç—Ç–æ –ø–æ–º–æ–∂–µ—Ç –Ω–∞–º —Å—Ç–∞—Ç—å –ª—É—á—à–µ. üòä"
    )

    grade_material_keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text='üëç', callback_data=f'like_material:{material_id}'), InlineKeyboardButton(text='üëé', callback_data=f'dislike_material:{material_id}')]
        ]
    )
    
    await callback_query.message.answer_document(document, caption=caption_text, reply_markup=grade_material_keyboard)
    await callback_query.message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞–ª—å–Ω–µ–π—à–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=material_menu 
    )
    
    # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    os.remove(zip_filename)
    os.rmdir(user_folder)

    await state.clear()







# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π –∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∏—Ö –≤ –æ–±—â–µ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ
@router.message(MaterialStates.files_id, F.content_type == 'photo')
async def process_photo(message: types.Message, state: FSMContext):

    # –ü–æ–ª—É—á–∞–µ–º id –ª—É—á—à–µ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    best_photo = max(message.photo, key=lambda p: p.width * p.height)

    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    data = await state.get_data()
    files = data.get('files', [])  # –ü–æ–ª—É—á–∞–µ–º –æ–±—â–∏–π —Å–ø–∏—Å–æ–∫ –¥–∞–Ω–Ω—ã—Ö
    files.append({'type': 'photo', 'file_id': best_photo.file_id})  # –î–æ–±–∞–≤–ª—è–µ–º —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é —Å —É–∫–∞–∑–∞–Ω–∏–µ–º —Ç–∏–ø–∞

    # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    await state.update_data(files=files)
    await message.reply(
        "–§–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–∞! –í—ã –º–æ–∂–µ—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –µ—â—ë —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏, –¥–æ–∫—É–º–µ–Ω—Ç—ã –∏–ª–∏ –∑–∞–≤–µ—Ä—à–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å.",
        reply_markup=complete_process
    )
